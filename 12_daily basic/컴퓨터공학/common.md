## RESTful API

API 설계의 중심에 자원(Resource)이 있고 HTTP Method를 통해 자원을 처리하도록 설계한다. REST의 기본 원칙을 성실히 지킨 서비스 디자인은 RESTful하다고 표현할 수 있다.

1. 리소스와 행위를 명시적이고 직관적으로 분리한다.
   - 리소스는 URI, 리소스가 가리키는 것은 명사로 표현
   - 행위는 HTTP Method로 표현. GET, POST, PUT, PATCH, DELETE를 분명한 목적으로 사용
2. Message는 Header와 Body를 명확하게 분리해서 사용한다.
   - Entity에 대한 내용은 Body에 담는다.
   - API 버전 정보, 응답받고자 하는 타입 등은 Header에 담는다.
3. API 버전을 관리한다.
   - API의 signature가 변경될 수 있음에 유의
   - 특정 API를 변경할 때는 하위호환성을 보장해야 한다.
4. 서버와 클라이언트가 같은 방식을 사용해서 요청한다.
   - form-data, json 등 브라우저에서의 통신 방식을 하나로 통일한다.

#### 장점

- Open API 제공 쉬움, HTTP 사용

#### 단점

- 메소드가 4개뿐, 분산환경에는 부적합



## OOP (Object Oriented Programming)

객체 지향 프로그래밍 이전에는, 중심이 컴퓨터고, 컴퓨터가 사고하는대로 프로그래밍을 했다.

하지만 객체 지향 프로그래밍이란 인간 중심적 프로그래밍 패러다임이라고 할 수 있다. 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이다. 이것을 **추상화**라고 한다.

#### 장점

1. OOP로 코드를 작성하면 코드의 재사용성이 높다. 
2. 자주 사용되는 로직을 라이브러리로 만들어두면 신뢰성을 확보할 수 있고, 에러를 컴파일 단계에서 잡아낼 수 있어 버그 발생이 줄어든다.
3. 생산성이 높아진다. 디버깅, 유지보수에 용이하다. 
4. 데이터 모델링을 할 때 객체와 매핑하는 것이 수월하기 때문에 요구사항을 명확하게 파악하여 프로그래밍 할 수 있다.

#### 단점

1. 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 오버헤드가 발생한다. -> 그렇지만 하드웨어의 발전으로 많이 보완되었다.
2. 객체가 상태를 갖는다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킨다. -> 함수형 패러다임이 주목받고 있다.



## FP (Functional Programming)

함수형 프로그래밍은 애플리케이션, 함수의 구성요소, 더 나아가서 언어 자체를 함수처럼 여기도록 만들고, 함수 개념을 가장 우선순위에 놓는다.

함수형 사고방식은 문제의 해결 방법을 동사(함수)들로 구성(조합)하는 것

#### first class citizen

함수형 프로그래밍 패러다임을 따르고 있는 언어에서 function은 first class citizen으로 간주된다.

- 변수나 데이터 구조안에 함수를 담을 수 있어서 함수의 파라미터로 전달할 수 있고, 함수의 반환값으로 사용할 수 있다.
- 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다.
- 함수를 리터럴로 바로 정의할 수 있다.



```javascript
// 데이터(객체) 기준
// 데이터를 기재하고, 메서드를 만든다
duck.moveLeft();

// 함수 기준
// 함수를 만들고, 함수에 데이터를 맞춘다
moveLeft(duck)
moveRight({x:5, y:2});
```



## TDD (Test-Driven Development)

매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스이다. 

개발자는 요구되는 새로운 기능에 대한 자동화된 테스트케이스를 작성하고 해당 테스트를 통과하는 가장 간단한 코드를 작성한다. 

일단 테스트를 통과하는 코드를 작성하고 상황에 맞게 리팩토링하는 과정을 거친다.

테스트를 작성하기 위해서, 개발자는 해당 기능의 요구사항과 명세를 분명히 이해하고 있어야 한다.



코드량이 늘어나기 때문에 빠른 생산성이 요구될 때는 TDD가 걸림돌이 될 수 있다.



## DDD (Domain-Driven Design)

실세계에서 사건이 발생하는 집합인 Domain을 중심으로 설계하는 방법.

DDD에서는 같은 객체들이 존재할 수 있다. 예를 들어, 옷 구매자의 입장에서 (name, price)와 같은 객체 정보를 담았을 때 판매자의 입장에서는 (madeTie, size, madeCountry) 등으로 문맥에 따라 객체의 역할이 바뀐다.

구매자, 판매자 등 도메인이 각각 분리되어 있어, MSA에 적용하면 용이한 설계를 할 수 있다.



## MSA (Microservice Architecture)

모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 모놀리식 아키텍처(Monolithic Architecture)의 한계점을 극복하고자 등장.

1개의 시스템을 독립적으로 배포 가능한 각각의 서비스로 분할. 각각의 서비스는 RESTful API를 통해 데이터를 주고받으며 1개의 큰 서비스를 구성.

#### 장점

- 일부 서비스의 장애가 전체 서비스에 영향을 미치지 않는다
- 각각의 서비스들은 서로 다른 언어와 프레임워크로 구성될 수 있다
- 서비스의 확장이 용이하다

#### 단점

- 서비스가 분리되어 있어 테스팅이나 트랜잭션 처리 등이 어렵다
- 서비스간 RESTful API 통신 비용이 발생한다
- 서비스간 호출이 연속적이기 때문에 디버깅이 어렵다



