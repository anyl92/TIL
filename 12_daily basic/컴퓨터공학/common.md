## RESTful API

API 설계의 중심에 자원(Resource)이 있고 HTTP Method를 통해 자원을 처리하도록 설계한다. REST의 기본 원칙을 성실히 지킨 서비스 디자인은 RESTful하다고 표현할 수 있다.

1. 리소스와 행위를 명시적이고 직관적으로 분리한다.
   - 리소스는 URI, 리소스가 가리키는 것은 명사로 표현
   - 행위는 HTTP Method로 표현. GET, POST, PUT, PATCH, DELETE를 분명한 목적으로 사용
2. Message는 Header와 Body를 명확하게 분리해서 사용한다.
   - Entity에 대한 내용은 Body에 담는다.
   - API 버전 정보, 응답받고자 하는 타입 등은 Header에 담는다.
3. API 버전을 관리한다.
   - API의 signature가 변경될 수 있음에 유의
   - 특정 API를 변경할 때는 하위호환성을 보장해야 한다.
4. 서버와 클라이언트가 같은 방식을 사용해서 요청한다.
   - form-data, json 등 브라우저에서의 통신 방식을 하나로 통일한다.

#### 장점

- Open API 제공 쉬움, HTTP 사용

#### 단점

- 메소드가 4개뿐, 분산환경에는 부적합



## OOP (Object Oriented Programming)

객체 지향 프로그래밍 이전에는, 중심이 컴퓨터고, 컴퓨터가 사고하는대로 프로그래밍을 했다.

하지만 객체 지향 프로그래밍이란 인간 중심적 프로그래밍 패러다임이라고 할 수 있다. 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이다. 이것을 **추상화**라고 한다.

#### 장점

1. OOP로 코드를 작성하면 코드의 재사용성이 높다. 
2. 자주 사용되는 로직을 라이브러리로 만들어두면 신뢰성을 확보할 수 있고, 에러를 컴파일 단계에서 잡아낼 수 있어 버그 발생이 줄어든다.
3. 생산성이 높아진다. 디버깅, 유지보수에 용이하다. 
4. 데이터 모델링을 할 때 객체와 매핑하는 것이 수월하기 때문에 요구사항을 명확하게 파악하여 프로그래밍 할 수 있다.

#### 단점

1. 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 오버헤드가 발생한다. -> 그렇지만 하드웨어의 발전으로 많이 보완되었다.
2. 객체가 상태를 갖는다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그를 발생시킨다. -> 함수형 패러다임이 주목받고 있다.



## FP (Functional Programming)

함수형 프로그래밍은 애플리케이션, 함수의 구성요소, 더 나아가서 언어 자체를 함수처럼 여기도록 만들고, 함수 개념을 가장 우선순위에 놓는다.

함수형 사고방식은 문제의 해결 방법을 동사(함수)들로 구성(조합)하는 것

#### first class citizen

함수형 프로그래밍 패러다임을 따르고 있는 언어에서 function은 first class citizen으로 간주된다.

- 변수나 데이터 구조안에 함수를 담을 수 있어서 함수의 파라미터로 전달할 수 있고, 함수의 반환값으로 사용할 수 있다.
- 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다.
- 함수를 리터럴로 바로 정의할 수 있다.



```javascript
// 데이터(객체) 기준
// 데이터를 기재하고, 메서드를 만든다
duck.moveLeft();

// 함수 기준
// 함수를 만들고, 함수에 데이터를 맞춘다
moveLeft(duck)
moveRight({x:5, y:2});
```



## TDD (Test-Driven Development)

매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스이다. 

개발자는 요구되는 새로운 기능에 대한 자동화된 테스트케이스를 작성하고 해당 테스트를 통과하는 가장 간단한 코드를 작성한다. 

일단 테스트를 통과하는 코드를 작성하고 상황에 맞게 리팩토링하는 과정을 거친다.

테스트를 작성하기 위해서, 개발자는 해당 기능의 요구사항과 명세를 분명히 이해하고 있어야 한다.



코드량이 늘어나기 때문에 빠른 생산성이 요구될 때는 TDD가 걸림돌이 될 수 있다.



## DDD (Domain-Driven Design)

실세계에서 사건이 발생하는 집합인 Domain을 중심으로 설계하는 방법.

DDD에서는 같은 객체들이 존재할 수 있다. 예를 들어, 옷 구매자의 입장에서 (name, price)와 같은 객체 정보를 담았을 때 판매자의 입장에서는 (madeTie, size, madeCountry) 등으로 문맥에 따라 객체의 역할이 바뀐다.

구매자, 판매자 등 도메인이 각각 분리되어 있어, MSA에 적용하면 용이한 설계를 할 수 있다.



## MSA (Microservice Architecture)

모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 모놀리식 아키텍처(Monolithic Architecture)의 한계점을 극복하고자 등장.

1개의 시스템을 독립적으로 배포 가능한 각각의 서비스로 분할. 각각의 서비스는 RESTful API를 통해 데이터를 주고받으며 1개의 큰 서비스를 구성.

#### 장점

- 일부 서비스의 장애가 전체 서비스에 영향을 미치지 않는다
- 각각의 서비스들은 서로 다른 언어와 프레임워크로 구성될 수 있다
- 서비스의 확장이 용이하다

#### 단점

- 서비스가 분리되어 있어 테스팅이나 트랜잭션 처리 등이 어렵다
- 서비스간 RESTful API 통신 비용이 발생한다
- 서비스간 호출이 연속적이기 때문에 디버깅이 어렵다



## Parameter, Argument

- Parameter : 함수를 선언할 때 사용된 변수
- Argument : 함수가 호출되었을 때 함수의 파라미터로 전달된 실제 값



## Call By Value, Call By Reference

- Call By Value
  - 인자로 받은 값을 복사하여 처리
  - Call By Value에 의해 넘어온 값을 증가시켜도 원래의 값이 보존된다.
  - 값을 복사해서 넘기기 때문에 메모리 사용량이 늘어난다.
- Call By Reference
  - 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 줌
  - 값을 복사하지 않고 직접 참조하기 때문에 속도가 빠르다.
  - 원래의 값에 영향을 주는 리스크가 존재한다.



## 프레임워크, 라이브러리

- 프레임워크 : 전체적인 흐름을 자체적으로 제어한다.
- 라이브러리 : 사용자가 흐름에 대한 제어를 하며 필요한 상황에 가져다쓸 수 있다.

프레임워크와 라이브러리는 실행 흐름에 대한 제어 권한이 어디 있는지에 따라 달라진다. 프레임워크를 사용하면 사용자가 관리해야 하는 부분을 프레임워크에 넘김으로써 신경써야 할 것을 줄이는 제어의 역전(IoC, Inversion Of Control)이 적용된다.



## 병렬 처리 프레임워크

- Hadoop
  - HDFS(Hadoop Distributed File System)를 활용해 데이터를 주고 받는다. 
  - 데이터가 여러 노드에 분산되어 저장되기 때문에 손실의 우려가 없다는 장점
  - 하지만 File I/O를 기반으로 작동하기 때문에 처리 속도가 느린 단점
- Spark
  - In-Memory 상에서 데이터를 주고받고 연산을 수행한다.
  - 메모리를 사용해 데이터를 처리하기 때문에 Hadoop보다 약 100배 정도 속도가 빠른 것이 장점
  - 하지만 메모리상에서 처리하기 때문에 장애가 발생한 경우 응용 프로그램을 처음부터 다시 시작해야 하는 단점



## 동기와 비동기

- 동기(Synchronous)
  - 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식
  - 순서에 맞춰 진행되기 때문에 제어하기 쉬움
  - 여러 요청을 동시에 처리할 수 없어 효율이 떨어짐
  - 콜센터 종업원! 현재의 전화가 끝나야 다음 전화를 받을 수 있다.
- 비동기(Asynchronous)
  - 요청을 보내고 해당 동작의 처리 여부와 상관없이 다음 요청이 동작하는 방식
  - 작업이 완료되는 시간을 기다리지 않아 자원을 효율적으로 사용
  - 작업이 완료된 결과를 제어하기 어려움
  - 이메일! 이메일을 보낸 후 답변을 받지 않아도 새로운 이메일을 보낸다.