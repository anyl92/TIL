## 해시테이블

데이터가 키와 값으로 저장되어 탐색 알고리즘에 사용된다. 조회와 삽입 시 O(1)의 상수시간 소요로 가장 빠른 알고리즘이다.

```
data = [{key:'value'}]
hash(key) = 2
hashtable = [0, 0, (value, key)]
```

키를 hash 함수에 적용시킨 후 리턴값의 인덱스에 해당 키와 밸류값을 저장하거나 조회한다. 

다른 키 값인데 hash 함수의 리턴값이 같은 인덱스를 리턴하는 경우를 충돌이라고 한다. 충돌하는 값들을 처리하는 방법에는 두 가지가 있다.

- chaining
  - 같은 인덱스의 값에 중복되는 값들을 linked list로 연결한다.
- open address
  - 중복되는 값이 생길 경우 해당 인덱스의 다음 인덱스에 저장한다. 만약 중복되는 값이 삭제될 때는 값이 있었다가 삭제되었다는 표식을 남긴다.



# 트리

```python
Class Node:
    def init(self, item, lc, rc):
        self.item = item
        self.lc = lc
        self.rc = rc
    
tree = {}
for _ in input:
    data = input
    tree[data[0]] = Node(data[0], data[1], data[2])

def preorder(item):
    print(item.item)
    if item.lc != '.':
        preorder(tree[item.lc])
    if item.rc != '.':
        preorder(tree[item.rc])
    
preorder(tree['A'])
```



## 포화 이진 트리

모든 레벨이 꽉 찬 이진 트리. 이건 사실 의미 없다! 그렇지만 탐색은 잘 되겠지. 모든 노드에 logn이라는 속도.



## 완전 이진 트리

노드의 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리. 힙(우선순위 큐)을 효율적으로 만들 수 있다. 

#### Heap

배열에 트리의 값들을 넣어줄 때, 0번째는 건너뛰고 1번 idx부터 루트 노드가 시작된다. 배열의 idx와 노드의 고유번호값을 일치시켜 혼동을 줄이기 위함이다.

힙에는 최대힙, 최소힙이 있다.

최대힙은 각 노드의 값이 해당 child 값보다 크거나 같은 트리를 말한다. 최소힙은 각 노드의 값이 해당 child 값보다 작은 트리를 말한다.

하지만 힙의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지한다. 결국 O(log n)의 시간복잡도로 최댓값 혹은 최솟값에 접근할 수 있다.



## BST (Binary Search Tree)

이진 탐색 트리에는 데이터를 저장하는 규칙이 있다.

1. 이진 탐색 트리의 노드에 저장된 키는 유일하다.
2. 부모의 키가 왼쪽 자식 노드의 키보다 크다.
3. 부모의 키가 오른쪽 자식 노드의 키보다 작다.
4. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.



## RBT (Red Black Tree)

BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어진 자료구조.



# 그래프

트리도 그래프(무방향).

그래프틑 정점의 구성 뿐만 아니라 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다. 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다.

## DFS (Depth First Search) - 깊이 우선 탐색

일단 연결된 정점으로 탐색을 계속한다. 스택. 미로찾기.

시간복잡도 O(V+E)

## BFS (Breadth First Search) - 너비 우선 탐색

임의의 정점에서 연결된 모든 정점으로 탐색한다. 큐. **최소/최단 경로**

시간복잡도 O(V+E)